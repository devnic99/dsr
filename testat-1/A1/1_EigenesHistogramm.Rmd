---
title: "Eigenes Histogramm"
output: html_document
---

# Eigenes Histogramm

Es soll ein eigenes Histogramm erzeugt werden. Der Dateiname für das Skript ist `myhistogram.R`.

## Funktion `myhistogram`

Programmieren Sie in R die Funktion `myhistogram`, die als Parameter `x` einen Vektor aus Zahlen erhält. 
Die Zahlen werden in `n` Intervalle einsortiert, und es wird gezählt, wie oft eine Zahl in einem Intervall vorkommt. 
Der Rückgabewert ist eine Liste mit den Einträgen `borders`, die die $n+1$ Intervallgrenzen enthalten und `counts`, der die Anzahlen enthält.

 * Die $n$ Intervalle sollen gleich groß sein ($\Delta b$), d.h. für die Intervallgrenzen 
 $b_1, b_2, \ldots, b_{n+1}$ gilt $\frac{b_{i+1}-b_{i}}{n}=\Delta b$ für $i=1, 2, \ldots n$.
 * Die äußeren Grenzen $b_1$ und $b_n$ sollen als optionale Parametern `min` und `max` an die Funktion übergeben werden. Werte aus `x`, 
 die zu keinem Intervall gehören, sollen ignoriert werden. Es wird aber eine Warnung ausgegeben, die sagt, welche Zahlen außerhalb des Bereichs liegen.
 * Eine Zahl $z$ gehört zum $i$-ten Intervall, falls $b_i \leq z < b_{i+1}$ gilt.

Bis auf `x` sollen alle Parameter optional sein. Überlegen Sie sinnvolle Default-Werte.

Es ist natürlich **nicht** erlaubt, in der eigenen Funktion andere Funktionen zu nutzen, die ein Histogramm erzeugen.

Hier ein Beispiel:
```{r eval = F}
# Bitte mit echter Lösung in myhistogram.R ersetzen:
myhistogram = function(x, n = length(x)-1, min = base::min(x) as.integer(.Machine$integer.min), my_max = as.integer(.Machine$integer.max)) { # in extra file, als default nicht min(x) max(x) sondern einfach maximal mögliches
  delta_b = abs(my_max-my_min) / n  # abs eig nicht nötig
  borders = seq(from = my_min, to = my_max, by = delta_b)
  counts = replicate(length(borders)-1, 0)
  ignored_vals = c()

  for (ele in x) {
    if (ele < my_min || ele > my_max) {     # vlt if in schleife weg
      ignored_vals = c(ignored_vals, ele)
    } else {
      for (i in 1:(length(borders)-1)) {
        if (ele >= borders[i] && ele < borders[i+1]) {
          counts[i] = counts[i] + 1
          break
        }
      }
    }
  }

  if (length(ignored_vals) != 0) {
    warn_msg = paste("Folgende Werte befinden sich außerhalb des vorgegebenen Bereichs: ", paste(ignored_vals, collapse = ", "))
    warning(warn_msg)
  }

  res = list(borders = borders, counts = counts)
  return(res)
}

x = seq(-5, 6, by = 1 / 3)
l = myhistogram(x)
print(l$borders)
print(l$counts)
```



## Beispieldaten

Hier zunächst zwei Beispiele.

### Beispiel 1

Es wird eine Warnung ausgeben:
```
## Warning in myhistogram(x, n = 10, min = -5, max = 6): Zahl(en) außerhalb
## Intervallgrenzen: 6
```

```{r}
x = seq(-5, 6, by = 1 / 3)
myhistogram(x, n = 10, my_min = -5, my_max = 6)
solution = list(
  borders = c(-5.0, -3.9, -2.8, -1.7, -0.6, 0.5, 1.6, 2.7, 3.8, 4.9, 6.0),
  counts = c(4, 3, 3, 4, 3, 3, 4, 3, 3, 3)
)
```

### Beispiel 2

```{r}
x = seq(-5, 6, by = 1 / 3)
myhistogram(x, n = 5, my_min = -10, my_max = 10)
solution = list(borders = c(-10, -6, -2, 2, 6, 10),
                counts = c(0, 9, 12, 12, 1))
```

### Beispiel 3

Testen Sie nun hier Ihre Funktion mit weiteren Datensätzen.

```{r}
#x = seq(-5, 6, by = 1 / 3)
#myhistogram(x, n = 5, my_min = -10, my_max = 10)
#solution = list(borders = c(-10, -6, -2, 2, 6, 10),
#                counts = c(0, 9, 12, 12, 1))
```

### Beispiel 4

Testen Sie nun hier Ihre Funktion mit weiteren Datensätzen.

```{r}
#x = seq(-5, 6, by = 1 / 3)
#myhistogram(x, n = 5, my_min = -10, my_max = 10)
#solution = list(borders = c(-10, -6, -2, 2, 6, 10),
#                counts = c(0, 9, 12, 12, 1))
```

### Beispiel 5

Testen Sie nun hier Ihre Funktion mit weiteren Datensätzen.

```{r}
#x = seq(-5, 6, by = 1 / 3)
#myhistogram(x, n = 5, my_min = -10, my_max = 10)
#solution = list(borders = c(-10, -6, -2, 2, 6, 10),
#                counts = c(0, 9, 12, 12, 1))
```

## Barplot

Nutzen Sie Ihre Funktion `myhistogram` und erzeugen Sie einen Barplot mit _ggplot_. Die _x_-Achse zeigt dabei die Mitte des Intervalls und die _y_-Achse die Anzahl der Elemente in dieser Klasse.

Tipp: Der Parameter `stat` von `geom_bar` ist wichtig.

Vervollständigen Sie den Chunk. Die Kommentare sollen zu Anweisungen umgewandelt werden:

```{r}
library("ggplot2")
set.seed(1)
x = rnorm(0, 1, n = 1000)
h = myhistogram(x, n = 20)

mittelpunkte = (h$borders[-1] + h$borders[-length(h$borders)]) / 2
print(h)
print(mittelpunkte)

df = data.frame(borders = mittelpunkte, counts = h$counts[])
ggplot(df) +
  geom_bar(aes(x = borders, y = counts, fill=counts), stat="identity")
```
